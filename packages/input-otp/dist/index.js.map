{"version":3,"sources":["../src/index.ts","../src/input.tsx","../src/regexp.ts","../src/sync-timeouts.ts","../src/use-previous.ts","../src/use-pwm-badge.tsx"],"sourcesContent":["export * from './input'\nexport * from './regexp'\nexport { OTPInputProps, SlotProps, RenderProps } from './types'\n","'use client'\n\nimport * as React from 'react'\n\nimport { REGEXP_ONLY_DIGITS } from './regexp'\nimport { syncTimeouts } from './sync-timeouts'\nimport { OTPInputProps, RenderProps } from './types'\nimport { usePrevious } from './use-previous'\nimport { usePasswordManagerBadge } from './use-pwm-badge'\n\nexport const OTPInputContext = React.createContext<RenderProps>(\n  {} as RenderProps,\n)\n\nexport const OTPInput = React.forwardRef<HTMLInputElement, OTPInputProps>(\n  (\n    {\n      value: uncheckedValue,\n      onChange: uncheckedOnChange,\n      maxLength,\n      textAlign = 'left',\n      pattern = REGEXP_ONLY_DIGITS,\n      inputMode = 'numeric',\n      onComplete,\n      pushPasswordManagerStrategy = 'increase-width',\n      containerClassName,\n      noScriptCSSFallback = NOSCRIPT_CSS_FALLBACK,\n\n      render,\n      children,\n\n      ...props\n    },\n    ref,\n  ) => {\n    // Only used when `value` state is not provided\n    const [internalValue, setInternalValue] = React.useState(\n      typeof props.defaultValue === 'string' ? props.defaultValue : '',\n    )\n\n    // Definitions\n    const value = uncheckedValue ?? internalValue\n    const previousValue = usePrevious(value)\n    const onChange = React.useCallback(\n      (newValue: string) => {\n        uncheckedOnChange?.(newValue)\n        setInternalValue(newValue)\n      },\n      [uncheckedOnChange],\n    )\n    const regexps = React.useMemo(() => {\n      // Check if pattern is a string or an array and handle accordingly\n      if (typeof pattern === 'string') {\n        return Array(maxLength).fill(new RegExp(pattern));\n      } else {\n        return pattern.map(p => p.regex);\n      }\n    }, [pattern, maxLength]);\n\n    /** useRef */\n    const inputRef = React.useRef<HTMLInputElement>(null)\n    const containerRef = React.useRef<HTMLDivElement>(null)\n    const initialLoadRef = React.useRef({\n      value,\n      onChange,\n      isIOS:\n        typeof window !== 'undefined' &&\n        window?.CSS?.supports?.('-webkit-touch-callout', 'none'),\n    })\n    const inputMetadataRef = React.useRef<{\n      prev: [number | null, number | null, 'none' | 'forward' | 'backward']\n    }>({\n      prev: [\n        inputRef.current?.selectionStart,\n        inputRef.current?.selectionEnd,\n        inputRef.current?.selectionDirection,\n      ],\n    })\n    React.useImperativeHandle(ref, () => inputRef.current, [])\n    React.useEffect(() => {\n      const input = inputRef.current\n      const container = containerRef.current\n\n      if (!input || !container) {\n        return\n      }\n\n      // Sync input value\n      if (initialLoadRef.current.value !== input.value) {\n        initialLoadRef.current.onChange(input.value)\n      }\n\n      // Previous selection\n      inputMetadataRef.current.prev = [\n        input.selectionStart,\n        input.selectionEnd,\n        input.selectionDirection,\n      ]\n      function onDocumentSelectionChange() {\n        if (document.activeElement !== input) {\n          setMirrorSelectionStart(null)\n          setMirrorSelectionEnd(null)\n          return\n        }\n\n        // Aliases\n        const _s = input.selectionStart\n        const _e = input.selectionEnd\n        const _dir = input.selectionDirection\n        const _ml = input.maxLength\n        const _val = input.value\n        const _prev = inputMetadataRef.current.prev\n\n        // Algorithm\n        let start = -1\n        let end = -1\n        let direction: 'forward' | 'backward' | 'none' = undefined\n        if (_val.length !== 0 && _s !== null && _e !== null) {\n          const isSingleCaret = _s === _e\n          const isInsertMode = _s === _val.length && _val.length < _ml\n\n          if (isSingleCaret && !isInsertMode) {\n            const c = _s\n            if (c === 0) {\n              start = 0\n              end = 1\n              direction = 'forward'\n            } else if (c === _ml) {\n              start = c - 1\n              end = c\n              direction = 'backward'\n            } else if (_ml > 1 && _val.length > 1) {\n              let offset = 0\n              if (_prev[0] !== null && _prev[1] !== null) {\n                direction = c < _prev[1] ? 'backward' : 'forward'\n                const wasPreviouslyInserting =\n                  _prev[0] === _prev[1] && _prev[0] < _ml\n                if (direction === 'backward' && !wasPreviouslyInserting) {\n                  offset = -1\n                }\n              }\n\n              start = offset + c\n              end = offset + c + 1\n            }\n          }\n\n          if (start !== -1 && end !== -1 && start !== end) {\n            inputRef.current.setSelectionRange(start, end, direction)\n          }\n        }\n\n        // Finally, update the state\n        const s = start !== -1 ? start : _s\n        const e = end !== -1 ? end : _e\n        const dir = direction ?? _dir\n        setMirrorSelectionStart(s)\n        setMirrorSelectionEnd(e)\n        // Store the previous selection value\n        inputMetadataRef.current.prev = [s, e, dir]\n      }\n      document.addEventListener('selectionchange', onDocumentSelectionChange, {\n        capture: true,\n      })\n\n      // Set initial mirror state\n      onDocumentSelectionChange()\n      document.activeElement === input && setIsFocused(true)\n\n      // Apply needed styles\n      if (!document.getElementById('input-otp-style')) {\n        const styleEl = document.createElement('style')\n        styleEl.id = 'input-otp-style'\n        document.head.appendChild(styleEl)\n\n        if (styleEl.sheet) {\n          const autofillStyles =\n            'background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;'\n\n          safeInsertRule(\n            styleEl.sheet,\n            '[data-input-otp]::selection { background: transparent !important; color: transparent !important; }',\n          )\n          safeInsertRule(\n            styleEl.sheet,\n            `[data-input-otp]:autofill { ${autofillStyles} }`,\n          )\n          safeInsertRule(\n            styleEl.sheet,\n            `[data-input-otp]:-webkit-autofill { ${autofillStyles} }`,\n          )\n          // iOS\n          safeInsertRule(\n            styleEl.sheet,\n            `@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }`,\n          )\n          // PWM badges\n          safeInsertRule(\n            styleEl.sheet,\n            `[data-input-otp] + * { pointer-events: all !important; }`,\n          )\n        }\n      }\n      // Track root height\n      const updateRootHeight = () => {\n        if (container) {\n          container.style.setProperty(\n            '--root-height',\n            `${input.clientHeight}px`,\n          )\n        }\n      }\n      updateRootHeight()\n      const resizeObserver = new ResizeObserver(updateRootHeight)\n      resizeObserver.observe(input)\n\n      return () => {\n        document.removeEventListener(\n          'selectionchange',\n          onDocumentSelectionChange,\n          { capture: true },\n        )\n        resizeObserver.disconnect()\n      }\n    }, [])\n\n    /** Mirrors for UI rendering purpose only */\n    const [isHoveringInput, setIsHoveringInput] = React.useState(false)\n    const [isFocused, setIsFocused] = React.useState(false)\n    const [mirrorSelectionStart, setMirrorSelectionStart] = React.useState<\n      number | null\n    >(null)\n    const [mirrorSelectionEnd, setMirrorSelectionEnd] = React.useState<\n      number | null\n    >(null)\n\n    /** Effects */\n    React.useEffect(() => {\n      syncTimeouts(() => {\n        // Forcefully remove :autofill state\n        inputRef.current?.dispatchEvent(new Event('input'))\n\n        // Update the selection state\n        const s = inputRef.current?.selectionStart\n        const e = inputRef.current?.selectionEnd\n        const dir = inputRef.current?.selectionDirection\n        if (s !== null && e !== null) {\n          setMirrorSelectionStart(s)\n          setMirrorSelectionEnd(e)\n          inputMetadataRef.current.prev = [s, e, dir]\n        }\n      })\n    }, [value, isFocused])\n\n    React.useEffect(() => {\n      if (previousValue === undefined) {\n        return\n      }\n\n      if (\n        value !== previousValue &&\n        previousValue.length < maxLength &&\n        value.length === maxLength\n      ) {\n        onComplete?.(value)\n      }\n    }, [maxLength, onComplete, previousValue, value])\n\n    const pwmb = usePasswordManagerBadge({\n      containerRef,\n      inputRef,\n      pushPasswordManagerStrategy,\n      isFocused,\n    })\n\n    /** Event handlers */\n    const _changeListener = React.useCallback(\n      (e: React.ChangeEvent<HTMLInputElement>) => {\n        const newValue = e.currentTarget.value.slice(0, maxLength);\n        \n        let isValid = true; // Assume the input is valid initially\n    \n        // Validate each character against its corresponding regex if pattern is an array, else use a single regex for all\n        Array.from(newValue).forEach((char, index) => {\n          if (Array.isArray(pattern)) {\n            // pattern is expected to be { regex: RegExp }[]\n            if (pattern[index] && !pattern[index].regex.test(char)) {\n              isValid = false; // invalidate the input as soon as a mismatch is found\n            }\n          } else {\n            // Single regex pattern for all characters\n            const regex = new RegExp(pattern);\n            if (!regex.test(char)) {\n              isValid = false; // invalidate the input as soon as a mismatch is found\n            }\n          }\n        });\n    \n        if (!isValid) {\n          e.preventDefault();\n          return;\n        }\n    \n        const maybeHasDeleted = typeof previousValue === 'string' && newValue.length < previousValue.length;\n        if (maybeHasDeleted) {\n          // Manually trigger selection change event for deletions/cuts\n          document.dispatchEvent(new Event('selectionchange'));\n        }\n    \n        onChange(newValue);\n      },\n      [maxLength, onChange, previousValue, pattern] // Ensure 'pattern' is included in dependency array\n    );\n    const _focusListener = React.useCallback(() => {\n      if (inputRef.current) {\n        const start = Math.min(inputRef.current.value.length, maxLength - 1)\n        const end = inputRef.current.value.length\n        inputRef.current?.setSelectionRange(start, end)\n        setMirrorSelectionStart(start)\n        setMirrorSelectionEnd(end)\n      }\n      setIsFocused(true)\n    }, [maxLength])\n    // Fix iOS pasting\n    const _pasteListener = React.useCallback(\n      (e: React.ClipboardEvent<HTMLInputElement>) => {\n        const input = inputRef.current;\n        if (!initialLoadRef.current.isIOS || !e.clipboardData || !input) {\n          return;\n        }\n    \n        const content = e.clipboardData.getData('text/plain');\n        e.preventDefault();\n    \n        const start = input.selectionStart;\n        const end = input.selectionEnd;\n    \n        const isReplacing = start !== end;\n    \n        const newValueUncapped = isReplacing\n          ? value.slice(0, start) + content + value.slice(end) // Replacing\n          : value.slice(0, start) + content + value.slice(start); // Inserting\n        const newValue = newValueUncapped.slice(0, maxLength);\n    \n        // Validate the new value based on pattern(s)\n        let isValid = true;\n        Array.from(newValue).forEach((char, index) => {\n          if (Array.isArray(pattern)) {\n            // pattern is expected to be { regex: RegExp }[]\n            if (pattern[index] && !pattern[index].regex.test(char)) {\n              isValid = false;\n            }\n          } else {\n            // Single regex pattern for all characters\n            const regex = new RegExp(pattern);\n            if (!regex.test(char)) {\n              isValid = false;\n            }\n          }\n        });\n    \n        if (!isValid) {\n          return;\n        }\n    \n        input.value = newValue; // Only update input value if all characters are valid\n        onChange(newValue);\n    \n        const _start = Math.min(newValue.length, maxLength - 1);\n        const _end = newValue.length;\n    \n        input.setSelectionRange(_start, _end);\n        setMirrorSelectionStart(_start);\n        setMirrorSelectionEnd(_end);\n      },\n      [maxLength, onChange, pattern, value] // Update dependencies to include pattern\n    );\n    \n\n    /** Styles */\n    const rootStyle = React.useMemo<React.CSSProperties>(\n      () => ({\n        position: 'relative',\n        cursor: props.disabled ? 'default' : 'text',\n        userSelect: 'none',\n        WebkitUserSelect: 'none',\n        pointerEvents: 'none',\n      }),\n      [props.disabled],\n    )\n\n    const inputStyle = React.useMemo<React.CSSProperties>(\n      () => ({\n        position: 'absolute',\n        inset: 0,\n        width: pwmb.willPushPWMBadge\n          ? `calc(100% + ${pwmb.PWM_BADGE_SPACE_WIDTH})`\n          : '100%',\n        clipPath: pwmb.willPushPWMBadge\n          ? `inset(0 ${pwmb.PWM_BADGE_SPACE_WIDTH} 0 0)`\n          : undefined,\n        height: '100%',\n        display: 'flex',\n        textAlign,\n        opacity: '1', // Mandatory for iOS hold-paste\n        color: 'transparent',\n        pointerEvents: 'all',\n        background: 'transparent',\n        caretColor: 'transparent',\n        border: '0 solid transparent',\n        outline: '0 solid transparent',\n        boxShadow: 'none',\n        lineHeight: '1',\n        letterSpacing: '-.5em',\n        fontSize: 'var(--root-height)',\n        fontFamily: 'monospace',\n        fontVariantNumeric: 'tabular-nums',\n        // letterSpacing: '-1em',\n        // transform: 'scale(1.5)',\n        // paddingRight: '100%',\n        // paddingBottom: '100%',\n        // debugging purposes\n        // inset: undefined,\n        // position: undefined,\n        // color: 'black',\n        // background: 'white',\n        // opacity: '1',\n        // caretColor: 'black',\n        // padding: '0',\n        // letterSpacing: 'unset',\n        // fontSize: 'unset',\n        // paddingInline: '.5rem',\n      }),\n      [pwmb.PWM_BADGE_SPACE_WIDTH, pwmb.willPushPWMBadge, textAlign],\n    )\n\n    /** Rendering */\n    const renderedInput = React.useMemo(\n      () => (\n        <input\n          autoComplete={props.autoComplete || 'one-time-code'}\n          {...props}\n          data-input-otp\n          data-input-otp-mss={mirrorSelectionStart}\n          data-input-otp-mse={mirrorSelectionEnd}\n          inputMode={inputMode}\n          style={inputStyle}\n          maxLength={maxLength}\n          value={value}\n          ref={inputRef}\n          onPaste={e => {\n            _pasteListener(e)\n            props.onPaste?.(e)\n          }}\n          onChange={_changeListener}\n          onMouseOver={e => {\n            setIsHoveringInput(true)\n            props.onMouseOver?.(e)\n          }}\n          onMouseLeave={e => {\n            setIsHoveringInput(false)\n            props.onMouseLeave?.(e)\n          }}\n          onFocus={e => {\n            _focusListener()\n            props.onFocus?.(e)\n          }}\n          onBlur={e => {\n            setIsFocused(false)\n            props.onBlur?.(e)\n          }}\n        />\n      ),\n      [\n        _changeListener,\n        _focusListener,\n        _pasteListener,\n        inputMode,\n        inputStyle,\n        maxLength,\n        mirrorSelectionEnd,\n        mirrorSelectionStart,\n        props,\n        value,\n      ],\n    )\n\n    const contextValue = React.useMemo<RenderProps>(() => {\n      return {\n        slots: Array.from({ length: maxLength }).map((_, slotIdx) => {\n          const isActive =\n            isFocused &&\n            mirrorSelectionStart !== null &&\n            mirrorSelectionEnd !== null &&\n            ((mirrorSelectionStart === mirrorSelectionEnd &&\n              slotIdx === mirrorSelectionStart) ||\n              (slotIdx >= mirrorSelectionStart && slotIdx < mirrorSelectionEnd))\n\n          const char = value[slotIdx] !== undefined ? value[slotIdx] : null\n\n          return {\n            char,\n            isActive,\n            hasFakeCaret: isActive && char === null,\n          }\n        }),\n        isFocused,\n        isHovering: !props.disabled && isHoveringInput,\n      }\n    }, [\n      isFocused,\n      isHoveringInput,\n      maxLength,\n      mirrorSelectionEnd,\n      mirrorSelectionStart,\n      props.disabled,\n      value,\n    ])\n\n    const renderedChildren = React.useMemo(() => {\n      if (render) {\n        return render(contextValue)\n      }\n      return (\n        <OTPInputContext.Provider value={contextValue}>\n          {children}\n        </OTPInputContext.Provider>\n      )\n    }, [children, contextValue, render])\n\n    return (\n      <>\n        {noScriptCSSFallback !== null && (\n          <noscript>\n            <style>{noScriptCSSFallback}</style>\n          </noscript>\n        )}\n\n        <div\n          ref={containerRef}\n          data-input-otp-container\n          style={rootStyle}\n          className={containerClassName}\n        >\n          {renderedChildren}\n\n          <div\n            style={{\n              position: 'absolute',\n              inset: 0,\n              pointerEvents: 'none',\n            }}\n          >\n            {renderedInput}\n          </div>\n        </div>\n      </>\n    )\n  },\n)\nOTPInput.displayName = 'Input'\n\nfunction safeInsertRule(sheet: CSSStyleSheet, rule: string) {\n  try {\n    sheet.insertRule(rule)\n  } catch {\n    console.error('input-otp could not insert CSS rule:', rule)\n  }\n}\n\n// Decided to go with <noscript>\n// instead of `scripting` CSS media query\n// because it's a fallback for initial page load\n// and the <script> tag won't be loaded\n// unless the user has JS disabled.\nconst NOSCRIPT_CSS_FALLBACK = `\n[data-input-otp] {\n  --nojs-bg: white !important;\n  --nojs-fg: black !important;\n\n  background-color: var(--nojs-bg) !important;\n  color: var(--nojs-fg) !important;\n  caret-color: var(--nojs-fg) !important;\n  letter-spacing: .25em !important;\n  text-align: center !important;\n  border: 1px solid var(--nojs-fg) !important;\n  border-radius: 4px !important;\n  width: 100% !important;\n}\n@media (prefers-color-scheme: dark) {\n  [data-input-otp] {\n    --nojs-bg: black !important;\n    --nojs-fg: white !important;\n  }\n}`\n","export const REGEXP_ONLY_DIGITS = '^\\\\d+$'\nexport const REGEXP_ONLY_CHARS = '^[a-zA-Z]+$'\nexport const REGEXP_ONLY_DIGITS_AND_CHARS = '^[a-zA-Z0-9]+$'\n","export function syncTimeouts(cb: (...args: any[]) => unknown): number[] {\n  const t1 = setTimeout(cb, 0) // For faster machines\n  const t2 = setTimeout(cb, 1_0)\n  const t3 = setTimeout(cb, 5_0)\n  return [t1, t2, t3]\n}\n","import * as React from 'react'\n\nexport function usePrevious<T>(value: T) {\n  const ref = React.useRef<T>()\n  React.useEffect(() => {\n    ref.current = value\n  })\n  return ref.current\n}\n","import * as React from 'react'\nimport { OTPInputProps } from './types'\n\nconst PWM_BADGE_MARGIN_RIGHT = 18\nconst PWM_BADGE_SPACE_WIDTH_PX = 40\nconst PWM_BADGE_SPACE_WIDTH = `${PWM_BADGE_SPACE_WIDTH_PX}px` as const\n\nconst PASSWORD_MANAGERS_SELECTORS = [\n  '[data-lastpass-icon-root]', // LastPass\n  'com-1password-button', // 1Password\n  '[data-dashlanecreated]', // Dashlane\n  '[style$=\"2147483647 !important;\"]', // Bitwarden\n].join(',')\n\nexport function usePasswordManagerBadge({\n  containerRef,\n  inputRef,\n  pushPasswordManagerStrategy,\n  isFocused,\n}: {\n  containerRef: React.RefObject<HTMLDivElement>\n  inputRef: React.RefObject<HTMLInputElement>\n  pushPasswordManagerStrategy: OTPInputProps['pushPasswordManagerStrategy']\n  isFocused: boolean\n}) {\n  // Metadata for instant updates (not React state)\n  const pwmMetadata = React.useRef<{\n    done: boolean\n    refocused: boolean\n  }>({\n    done: false,\n    refocused: false,\n  })\n\n  /** Password managers have a badge\n   *  and I'll use this state to push them\n   *  outside the input */\n  const [hasPWMBadge, setHasPWMBadge] = React.useState(false)\n  const [hasPWMBadgeSpace, setHasPWMBadgeSpace] = React.useState(false)\n  const [done, setDone] = React.useState(false)\n\n  const willPushPWMBadge = React.useMemo(() => {\n    if (pushPasswordManagerStrategy === 'none') {\n      return false\n    }\n\n    const increaseWidthCase =\n      (pushPasswordManagerStrategy === 'increase-width' ||\n        // TODO: remove 'experimental-no-flickering' support in 2.0.0\n        pushPasswordManagerStrategy === 'experimental-no-flickering') &&\n      hasPWMBadge &&\n      hasPWMBadgeSpace\n\n    return increaseWidthCase\n  }, [hasPWMBadge, hasPWMBadgeSpace, pushPasswordManagerStrategy])\n\n  const trackPWMBadge = React.useCallback(() => {\n    const container = containerRef.current\n    const input = inputRef.current\n    if (\n      !container ||\n      !input ||\n      done ||\n      pushPasswordManagerStrategy === 'none'\n    ) {\n      return\n    }\n\n    const elementToCompare = container\n\n    // Get the top right-center point of the container.\n    // That is usually where most password managers place their badge.\n    const rightCornerX =\n      elementToCompare.getBoundingClientRect().left +\n      elementToCompare.offsetWidth\n    const centereredY =\n      elementToCompare.getBoundingClientRect().top +\n      elementToCompare.offsetHeight / 2\n    const x = rightCornerX - PWM_BADGE_MARGIN_RIGHT\n    const y = centereredY\n\n    // Do an extra search to check for famous password managers\n    const pmws = document.querySelectorAll(PASSWORD_MANAGERS_SELECTORS)\n\n    // If no password manager is automatically detect,\n    // we'll try to dispatch document.elementFromPoint\n    // to identify badges\n    if (pmws.length === 0) {\n      const maybeBadgeEl = document.elementFromPoint(x, y)\n\n      // If the found element is the input itself,\n      // then we assume it's not a password manager badge.\n      // We are not sure. Most times that means there isn't a badge.\n      if (maybeBadgeEl === container) {\n        return\n      }\n    }\n\n    setHasPWMBadge(true)\n    setDone(true)\n\n    // For specific password managers,\n    // the input has to be re-focused\n    // to trigger a re-position of the badge.\n    if (!pwmMetadata.current.refocused && document.activeElement === input) {\n      const sel = [input.selectionStart, input.selectionEnd]\n      input.blur()\n      input.focus()\n      // Recover the previous selection\n      input.setSelectionRange(sel[0], sel[1])\n\n      pwmMetadata.current.refocused = true\n    }\n  }, [containerRef, inputRef, done, pushPasswordManagerStrategy])\n\n  React.useEffect(() => {\n    const container = containerRef.current\n    if (!container || pushPasswordManagerStrategy === 'none') {\n      return\n    }\n\n    // Check if the PWM area is 100% visible\n    function checkHasSpace() {\n      const viewportWidth = window.innerWidth\n      const distanceToRightEdge =\n        viewportWidth - container.getBoundingClientRect().right\n      setHasPWMBadgeSpace(distanceToRightEdge >= PWM_BADGE_SPACE_WIDTH_PX)\n    }\n\n    checkHasSpace()\n    const interval = setInterval(checkHasSpace, 1000)\n\n    return () => {\n      clearInterval(interval)\n    }\n  }, [containerRef, pushPasswordManagerStrategy])\n\n  React.useEffect(() => {\n    const _isFocused = isFocused || document.activeElement === inputRef.current\n\n    if (pushPasswordManagerStrategy === 'none' || !_isFocused) {\n      return\n    }\n    const t1 = setTimeout(trackPWMBadge, 0)\n    const t2 = setTimeout(trackPWMBadge, 2000)\n    const t3 = setTimeout(trackPWMBadge, 5000)\n    const t4 = setTimeout(() => {\n      setDone(true)\n    }, 6000)\n    return () => {\n      clearTimeout(t1)\n      clearTimeout(t2)\n      clearTimeout(t3)\n      clearTimeout(t4)\n    }\n  }, [inputRef, isFocused, pushPasswordManagerStrategy, trackPWMBadge])\n\n  return { hasPWMBadge, willPushPWMBadge, PWM_BADGE_SPACE_WIDTH }\n}\n"],"mappings":"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","names":["React","React","_a","_b","_e","_c","_d"]}